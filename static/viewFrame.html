
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpeakEasy</title>
    <style>
    html, body {
        height: 100%;
        margin: 0;
        padding: 0;
    }
    
       body {
        font-family: 'Georgia', serif;
        text-align: center;
        margin: 50px;
        background-color: #591607;
        color: #f5f5f5;
        background-image: url("static/wooden-table-with-lights-in-background-free-photo.jpg");
        background-attachment: fixed;
        background-size: cover;
        background-repeat: no-repeat;
        background-position: center;
    }

    h1 {
        font-size: 60px;
        color: #f0e6d2;
        text-shadow: 2px 2px 5px #000;
        font-family: 'Georgia', serif;
        letter-spacing: 2px;
        margin-bottom: 30px;
    }

    #controls {
    background-color: rgba(0, 0, 0, 0.7);
    padding: 30px;
    border-radius: 15px;
    display: block; /* show controls by default */
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    max-width: 600px;
    margin: auto;
    }

    #translationSection {
    display: none; /* hide on first load */
    background-color: rgba(0, 0, 0, 0.7);
    padding: 30px;
    border-radius: 15px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    max-width: 600px;
    margin: auto;
    }

    label, select {
        font-size: 18px;
    }

    select {
        padding: 10px;
        font-size: 16px;
        border-radius: 8px;
        border: 1px solid #c19b77;
        background-color: #3e2c24;
        color: #f5f5f5;
    }

    button {
        padding: 12px 24px;
        font-size: 18px;
        margin-top: 20px;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        background-color: #7a4e2d;
        color: #f0e6d2;
        transition: background-color 0.3s, transform 0.2s;
    }

    button:hover {
        background-color: #a1623c;
        transform: scale(1.05);
    }

    .back {
        background-color: #9e2a2b;
    }

    .back:hover {
        background-color: #611111;
    }

    #feedbackText {
        font-weight: bold;
        margin-top: 15px;
        color: #ffd700;
        font-size: 20px;
        text-shadow: 1px 1px 3px #000;
    }

    #instructionText, #wordToTranslate {
        font-size: 24px;
        margin-top: 15px;
        color: #f5f5f5;
        text-shadow: 1px 1px 3px #000;
    }

    </style>
</head>
<body>
    <h1>SpeakEasy</h1>
<div id="controls">
    <!--<button onclick="startFunction()">Start</button>-->
    <button class="start">Start</button>

    
    <br><br>
    
    <label for="options">Choose a language:</label>
    <select id="options">
        <option value="French">French</option>
        <option value="Spanish">Spanish</option>
        <option value="English">English</option>
    </select>
</div>

    <div id="translationSection">
        <p id="feedbackText"></p>
        <p id="instructionText">Say the word in the selected language</p>
        <p id="wordToTranslate">test</p>
        <br><br>
        <p><strong>Audio Level:</strong> <span id="audioLevelDisplay">0 dB</span></p>
        <canvas id="waveform" width="600" height="100" style="display:block; margin:20px auto; background:transparent; border-radius:8px;"></canvas>
        <button class="back">Back</button>
    </div>

    <script>
        // --- Global variables for feedback/prompt separation ---
        let pendingWord = null;
        let feedbackAudioIsPlaying = false;
        let analyser;  // Global analyser
        let audioLevelsData;  // Global audioLevelsData
        let eventSource;
        let audio;
        let audioFetchController;

        const backBtn = document.querySelector('.back');

        function stopAllProcesses() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                console.log("Stopped mediaRecorder");
            }

            if (eventSource) {
                eventSource.close();
                console.log("Closed event source");
            }

            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                console.log("Stopped microphone stream");
            }

        fetch('/stop-lesson', { method: 'POST' });
    }

        function startLesson() {
            const selectedLanguage = document.getElementById("options").value;
            const wordToTranslate = document.getElementById("wordToTranslate");

            fetch('/start-lesson', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ language: selectedLanguage })
            })
            .then(response => response.json())
            .then(data => {
                document.getElementById("controls").style.display = "none";
                document.getElementById("translationSection").style.display = "block";
                instructionText.innerText = "Say the word in the selected language";


                //setWord();
                startEventSource();  // Start listening for updates 
            })
            .catch(error => console.error('Error:', error));
        }

        function startEventSource() {
            eventSource = new EventSource('/wordStream');

            eventSource.onmessage = function(event) {
                console.log("Received word:", event.data);

                if (event.data.startsWith("Correct!") || event.data.startsWith("Incorrect!")) {
                    feedbackText.innerText = event.data;
                    playFeedbackAudio();
                } else {
                    // It's a normal word
                    if (feedbackAudioIsPlaying === true) {
                        // Feedback audio is still playing, queue this word
                        pendingWord = event.data;
                    } else {
                        // Feedback audio is not playing, display and play prompt immediately
                        wordToTranslate.innerText = event.data;
                        wordToTranslate.style.visibility = "visible";
                        playPromptAudio(event.data);
                    }
                }
            };

            eventSource.onerror = function() {
                console.error("EventSource failed.");
                eventSource.close();
            };
        }
            
            

        function setWord(){
            fetch('/get_string')
            .then(response => response.json())
            .then(data => {
                document.getElementById('wordToTranslate').innerText = data.data;
            })
            .catch(error => console.error('Error:', error));
        }

        function stopLesson() {
            fetch('/stop-lesson', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                console.log("Lesson stopped:", data);
            })
            .catch(error => console.error('Error:', error));
        }

        function updateAudioLevels() {
            if (analyser) {
                analyser.getFloatFrequencyData(audioLevelsData);  
                
                
                let sum = 0;
                for (let i = 0; i < audioLevelsData.length; i++) {
                    sum += audioLevelsData[i];
                }
                let avgDb = sum / audioLevelsData.length;
                
                document.getElementById("audioLevelDisplay").innerText = avgDb.toFixed(2) + " dB";

                return avgDb;
            }
        }

        function startRecording(mediaRecorder) {
            audioChunks = [];
            backBtn.disabled = true;
            mediaRecorder.start();
            console.log("recorder started");

            monitorAudioLevels();
        }

        function monitorAudioLevels() {
            let startTime = performance.now();
            let levels = [];
            let baseline;

            function sampleBaseLine() {
                let currentLevel = updateAudioLevels();
                levels.push(currentLevel);

                if (performance.now() - startTime < 500) { // Collect baseline for 500ms
                    requestAnimationFrame(sampleBaseLine);
                } else {
                    baseline = levels.reduce((sum, val) => sum + val, 0) / levels.length;
                    console.log("Baseline Audio Level:", baseline);
                    listenForSpeech(baseline);
                }
            }

            function listenForSpeech(baseline) {
                let threshold = baseline + 10; // Set a threshold above baseline to detect speech
                let silenceDuration = 1000; // Silence time required to confirm speech has ended (1 sec)
                let speechStarted = false;
                let lastSpeechTime = 0;

                function detectSpeech() {
                    let currentLevel = updateAudioLevels();
                    let now = performance.now();

                    if (currentLevel > threshold) {
                        if (!speechStarted) {
                            console.log("Speech detected!");
                            speechStarted = true;
                        }
                        lastSpeechTime = now; // Reset silence timer
                    } else if (speechStarted && now - lastSpeechTime > silenceDuration) {
                        console.log("Speech ended, stopping recording.");
                        stopRecording(mediaRecorder);
                        return; 
                    }

                    if (now - startTime < 5000) { // 5 seconds max listening time
                        requestAnimationFrame(detectSpeech);
                    } 
                    else {
                        console.log("Max time reached, stopping recording.");
                        stopRecording(mediaRecorder);
                    }
                }

                detectSpeech();
            }

            sampleBaseLine();
        }
        

        function stopRecording(mediaRecorder) {
            wordToTranslate.style.visibility = "hidden";
            console.log("Word is now Hidden")
            mediaRecorder.stop();
            console.log(mediaRecorder.state);
            console.log("recorder stopped");
            document.getElementById("feedbackText").innerText = "Processing...";
            backBtn.disabled = false;
        }

        function handleStop(chunks) {
            const blob = new Blob(chunks, { type: 'audio/webm' });
            const file = new File([blob], "userAudio.webm", { type: 'audio/webm' });

            const formData = new FormData();
            formData.append('audio_file', file);

            fetch('/upload-audio', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error("Failed to upload audio");
                }
                return response.text();
            })
            .then(feedback => {
                console.log("Feedback received:", feedback);
                document.getElementById("feedbackText").innerText = feedback;

                console.log("Playing Feedback Audio...")

                playFeedbackAudio();

            })
            .catch(error => console.error('Error uploading file:', error));
        }

        function playFeedbackAudio() {
            if (audioFetchController) {
                audioFetchController.abort();
            }

            audioFetchController = new AbortController();
            const signal = audioFetchController.signal;
            feedbackAudioIsPlaying = true;

            fetch('/uploadFeedback', { signal })
                .then(response => {
                    if (!response.ok) {
                        throw new Error("Network response was not ok");
                    }
                    return response.blob();
                })
                .then(blob => {
                    const feedbackAudioBlobUrl = URL.createObjectURL(blob);
                    const feedbackAudio = new Audio(feedbackAudioBlobUrl);
                    feedbackAudio.addEventListener('ended', () => {
                        feedbackAudioIsPlaying = false;
                        if (pendingWord !== null) {
                            wordToTranslate.innerText = pendingWord;
                            wordToTranslate.style.visibility = "visible";
                            playPromptAudio(pendingWord);
                            pendingWord = null;
                        }
                    });
                    feedbackAudio.play();
                })
                .catch(error => {
                    if (error.name === "AbortError") {
                        console.log("Feedback fetch aborted.");
                    } else {
                        console.error("Fetch feedback error:", error);
                    }
                    feedbackAudioIsPlaying = false;
                });
        }

        function playPromptAudio(wordText) {
            if (audioFetchController) {
                audioFetchController.abort();
            }
            audioFetchController = new AbortController();
            const signal = audioFetchController.signal;
            fetch('/uploadAudio', { signal })
                .then(response => {
                    if (!response.ok) {
                        throw new Error("Network response was not ok");
                    }
                    return response.blob();
                })
                .then(blob => {
                    const audioBlobUrl = URL.createObjectURL(blob);
                    audio = new Audio(audioBlobUrl);
                    audio.addEventListener('ended', () => {
                        startRecording(mediaRecorder);
                    });
                    audio.play();
                })
                .catch(error => {
                    if (error.name === "AbortError") {
                        console.log("Prompt audio fetch aborted.");
                    } else {
                        console.error("Prompt fetch error:", error);
                    }
                });
        }

        const start = document.querySelector(".start");
        const startRecord = document.querySelector(".startRecord");
        const back = document.querySelector(".back");

        start.addEventListener("click", () => {
            wordToTranslate.style.visibility = "hidden";
            wordToTranslate.innerText = '';  // Clear word display
            
            startLesson();
            wordToTranslate.style.visibility = "visible"; 
            document.getElementById("controls").style.display = "none";
            document.getElementById("translationSection").style.display = "block";
            instructionText.innerText = "Say the word in the selected language";
        });

        back.addEventListener("click", stopAllProcesses => {

            fetch('/stop-lesson', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    console.log("Lesson stopped:", data.message);
            })
            .catch(error => {
                console.error("Error stopping lesson:", error);
            });

            if (audioFetchController) {
                audioFetchController.abort();
            }
            
            stopLesson();

            if (eventSource) {
                eventSource.close();
                eventSource = null;
                console.log("EventSource closed.")
            }

            if (audio) {
                audio.pause();
                audio.currentTime = 0;
                audio = null;
            }

            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop();
            }

            document.getElementById("controls").style.display = "block";
            document.getElementById("translationSection").style.display = "none";
            document.getElementById("wordToTranslate").innerText = "";
            document.getElementById("feedbackText").innerText = "";
            document.getElementById("audioLevelDisplay").innerText = "0 dB";
        });

        let mediaRecorder;

        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            console.log("getUserMedia supported.");
            navigator.mediaDevices.getUserMedia({audio: true})
            .then((stream) => {
                mediaRecorder = new MediaRecorder(stream);

                const audioContext = new AudioContext();
                const source = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();  // Assign to global analyser
                source.connect(analyser);

                analyser.fftSize = 512;  // Adjust for resolution
                analyser.smoothingTimeConstant = 0.8;

                audioLevelsData = new Float32Array(analyser.fftSize);  // Assign to global audioLevelsData

                const canvas = document.getElementById('waveform');
                const canvasCtx = canvas.getContext('2d');

                function drawWaveform() {
                    analyser.getFloatTimeDomainData(audioLevelsData);
                    canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
                    canvasCtx.beginPath();
                    const sliceWidth = canvas.width / audioLevelsData.length;
                    let x = 0;
                    for (let i = 0; i < audioLevelsData.length; i++) {
                    const v = audioLevelsData[i] * 1.50;
                    const y = (v + 1) * canvas.height / 2;
                    if (i === 0) canvasCtx.moveTo(x, y);
                    else          canvasCtx.lineTo(x, y);
                    x += sliceWidth;
                    }
                    canvasCtx.strokeStyle = 'white';
                    canvasCtx.lineWidth = 4;
                    canvasCtx.lineTo(canvas.width, canvas.height/2);
                    canvasCtx.stroke();
                }

                function visualize() {
                    drawWaveform();
                    requestAnimationFrame(visualize);
                }
                visualize();

                let audioChunks = [];

                mediaRecorder.addEventListener("dataavailable", (event) => {
                    audioChunks.push(event.data);
                });

                mediaRecorder.addEventListener("start", () => {
                    audioChunks = [];
                });

                mediaRecorder.addEventListener("stop", () => {
                    handleStop(audioChunks);
                });

                startRecord.addEventListener("click", () => {
                    audioChunks = [];
                    startRecording(mediaRecorder);
                });
            });
        } else {
            console.log("getUserMedia not supported on your browser!");
        }

    </script>
</body>
</html>